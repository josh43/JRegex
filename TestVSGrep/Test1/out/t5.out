Edge(unsigned char data)
Edge()
Vertex()
Vertex(Edge::EPSILON)
Vertex(unsigned char data)
Edge(data)
onTransition(unsigned char x)
pair(edge.v1, edge.v2)
printVertex( Vertex *& v)
printf("@Vertex: %p  isAccepting = %s\n",v,v->isAccepting ? "YES" : "NO")
printf("\t@Edge : %c",v->edge->val)
printf("\t@Edge->v1 : %p,v->edge->v1 isEpsilon : %s\n",v->edge->v1,v->edge->v1IsEpsilon ?"YES" : "NO")
printf("\t@Edge->v2 : %p,v->edge->v2 isEpsilon : %s\n",v->edge->v2,v->edge->v2IsEpsilon ?"YES" : "NO")
printf("@END VERTEX\n")
dfs(Vertex *curr, unsigned char x, int depth, vector<Vertex *> &toReset,bool verbose = false)
if(verbose)
printf("Already visited %p returning \n",curr)
printf("Ran out of depth returning \n")
back(curr)
printVertex(curr)
if(onTransition(x)
dfs(onTransition(x)
if(curr->edge == nullptr)
argument("Edge was null need to initalize!")
printf("Found x at %p returning vertex %p \n",curr,curr->edge->v1)
resetVerts(toReset)
printf("Searching at %p ->v1 %p  \n",curr,curr->edge->v1)
dfs(curr->edge->v1, depth - 1, x, toReset)
printf("Searching at %p ->v2 %p  \n",curr,curr->edge->v2)
dfs(curr->edge->v2, depth - 1, x, toReset)
resetVerts(vector<Vertex *> &toReset)
getGraphFrom(RegularDeque &regStack)
isEmpty()
argument("You need to at least have on character for matching a regexp")
Vertex(Edge::EPSILON)
pop()
if(type & DATA_NODE)
if(node->regularData != "")
front()
while(node)
Vertex(node->regularData.front()
specialExpression(type,curr,curr->edge->v1)
Vertex()
specialExpression(type,head,curr->edge->v2)
push({head,curr->edge->v2})
if(type & OR_NODE)
getDataNodeFrom(node->right)
while(node->nodeType & OR_NODE)
getDataNodeFrom(node->right)
orExpressions(last,orNode)
getDataNodeFrom(node)
orExpressions(last,orNode)
specialExpression(type,head,curr)
push({head,curr})
argument("Must either be a data node or an OR_NODE\n")
addTransition({},)
isEmpty()
printf("Completion\n")
if(vertStack.empty()
argument("You cannot have a null regular expression!!")
top()
top()
pop()
while(!vertStack.empty()
top()
if(curr->edge->v2)
argument("Cannot have the second vertex set when bridging!!")
pop()
orExpressions(pair<Vertex *, Vertex *> & one, pair<Vertex *, Vertex *> &two)
Vertex()
Vertex()
specialExpression(unsigned int type, Vertex *& start, Vertex *& end)
if(end == nullptr)
argument("End needs to not be nullptr!!")
if(type & PLUS_NODE)
if(!end->edge || end->edge->v2)
argument("This should not occur")
if(type & STAR_NODE)
if(end->edge->v1 || end->edge->v2)
argument("The End should not have any edges!!")
Vertex()
Vertex()
if(type & QUESTION_NODE)
if(end->edge->v1 || end->edge->v2)
argument("The End should not have any edges!!")
Vertex()
getDataNodeFrom(RegularNode * node)
Vertex()
if(node->regularData != "")
front()
while(node)
Vertex(node->regularData.front()
specialExpression(type,curr,curr->edge->v1)
while(node && node->nodeType == DATA_NODE)
Vertex(node->regularData.front()
specialExpression(node->nodeType,curr,curr->edge->v1)
if(curr == nullptr && start->edge->v1 == nullptr)
Vertex()
Vertex(Edge::EPSILON)
RegularGraph()
EpsilonNFA(Vertex * s, Vertex * e)
start(s)
end(e)
match(std::string str, bool verbose = false)
insert(start)
while(currentIndex < str.length()
if(str[currentIndex]< 0)
min()
if(canTransitionOn(str[currentIndex++],lastClosure,closure)
transition(closure,str[currentIndex])
foundEnd(closure, end)
back({str.substr(startIndex,currentIndex - startIndex)
clear()
insert(start)
if(verbose)
for(pair<string,int> match : matches)
printf( ANSI_COLOR_BLUE "  Match Found : %s @ %i" ANSI_COLOR_RESET " \n " ,match.first.c_str()
size()
canTransitionOn(unsigned char letter, const set<Vertex *> & lastClosure, set<Vertex *> &newClosure)
for(Vertex *v : lastClosure)
epsilonClosure(v)
insert(returned.begin()
end()
for(Vertex * v : temp)
for(Vertex *v : temp)
if(v->edge->val == letter)
if(v->edge->v1)
insert(v->edge->v1)
insert(v->edge->v2)
clear()
for(Vertex * v : newClosure)
epsilonClosure(v)
insert(returned.begin()
end()
move(temp)
epsilonClosure(Vertex * theVertex)
closureHelper(theVertex,verts)
for(auto v : verts)
closureHelper(Vertex * v,set<Vertex *> & vertList)
if(v == nullptr)
if(v->visited)
insert(v)
if(v->edge->v1IsEpsilon || v->edge->val == Edge::EPSILON)
closureHelper(v->edge->v1,vertList)
if(v->edge->v2IsEpsilon|| v->edge->val == Edge::EPSILON)
closureHelper(v->edge->v2,vertList)
foundEnd(set<Vertex *> & closure, Vertex * end)
for(auto x : closure)
if(x == end)
